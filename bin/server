#!/usr/bin/env python
# vim: tabstop=4 shiftwidth=4 softtabstop=4
#
# Copyright 2012 Sina Corporation
# All Rights Reserved.
# Author: YuWei Peng <pengyuwei@gmail.com>
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import sys
import time
import signal
import traceback
import ConfigParser
import json
import zmq
from kanyun.server import data_server
from kanyun.server.data_server import MSG_TYPE

from kanyun.database.cassadb import CassaDb
from kanyun.server.plugin_agent_srv import *

running = True
config = ConfigParser.ConfigParser()

if __name__ == '__main__':
    # register_plugin
    plugins = dict()
    plugins[MSG_TYPE.HEART_BEAT] = data_server.plugin_heartbeat
    plugins[MSG_TYPE.TRAFFIC_ACCOUNTING] = data_server.plugin_decoder_traffic_accounting
    plugins[MSG_TYPE.AGENT] = data_server.plugin_decoder_agent
    
    # register autotask
    autotasks = list()
    autotasks.append(data_server.autotask_heartbeat)
    # 

    config.read("kanyun.conf")
    server_cfg = dict(config.items('server'))
    data_server.register_signal()
    context = zmq.Context()

    # Socket to receive messages on
    handler = context.socket(zmq.REP)
    handler.bind("tcp://%(handler_host)s:%(handler_port)s" % server_cfg)
    print "listen tcp://%(handler_host)s:%(handler_port)s" % server_cfg

    # Socket to send messages on
    broadcast = context.socket(zmq.PUB)
    broadcast.bind("tcp://%(broadcast_host)s:%(broadcast_port)s" % server_cfg)
    print "listen tcp://%(broadcast_host)s:%(broadcast_port)s" % server_cfg

    # Socket with direct access to the feedback: used to syncronize start of batch
    feedback = context.socket(zmq.PULL)
    feedback.bind("tcp://%(feedback_host)s:%(feedback_port)s" % server_cfg)
    print "listen tcp://%(feedback_host)s:%(feedback_port)s" % server_cfg

    poller = zmq.Poller()
    poller.register(handler, zmq.POLLIN | zmq.POLLOUT)
    poller.register(feedback, zmq.POLLIN)

    # data DB
    db = CassaDb('data', server_cfg['db_host'])

    while True:
        try:
            socks = dict(poller.poll(20000))
        except zmq.core.error.ZMQError:
            pass
        
        # parse the data from worker and save to database
        if socks.get(feedback) == zmq.POLLIN:
            try:
                msg_type, report = feedback.recv_multipart()
            except zmq.core.error.ZMQError:
                pass
            
            if plugins.has_key(msg_type) and len(report) > 0:
                report_str = ''.join(report)
                print 'recv(%s):%s' % (msg_type, report_str)
                data = json.loads(report_str)
                try:
                    plugins[msg_type](db, data)
                except:
                    traceback.print_exc()
            else:
                print 'invaild data(%s):%s' % (msg_type, report_str)
            
        for task in autotasks:
            task()

#!/usr/bin/env python
# vim: tabstop=4 shiftwidth=4 softtabstop=4
#
# Copyright 2012 Sina Corporation
# All Rights Reserved.
# Author: YuWei Peng <pengyuwei@gmail.com>
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import json
import sys
import time
import signal
import zmq
import logging
import ConfigParser

from kanyun.common.const import *
from kanyun.worker.worker import *
from kanyun.database.cassadb import CassaDb


def main(param):
    if len(sys.argv) == 2 and sys.argv[1] == '--help':
        print 'usage:\nuse speical id: worker <id>\nuse id in config file: worker'
        return

    config = ConfigParser.ConfigParser()
    if len(config.read("kanyun.conf"))==0:
        config.read("/etc/kanyun.conf")
    cfg = dict(config.items('worker'))
    
    WORKER_ID = cfg['id']
    if len(sys.argv) == 2:
        if len(sys.argv[1]) > 16:
            print 'Invalid worker id.'
            return
        WORKER_ID = sys.argv[1]
    
    if not cfg.has_key('log'):
        cfg['log'] = "/tmp/worker.log"
    logger=logging.getLogger()
    handler=logging.FileHandler(cfg['log'])
    logger.addHandler(handler)
    logger.setLevel(logging.NOTSET)
    
    register_signal()

    running = param
    context = zmq.Context()

    # Socket for control input
    broadcast = context.socket(zmq.SUB)
    broadcast.connect("tcp://%(broadcast_host)s:%(broadcast_port)s" % cfg)
    broadcast.setsockopt(zmq.SUBSCRIBE, "lb")

    worker = Worker(context=context, feedback_host=cfg['feedback_host'], feedback_port=cfg['feedback_port'], logger=logger, worker_id=WORKER_ID)
    # TODO: the plugin come form configure file maybe better
    #worker.register_plugin(plugin_local_cpu)
    worker.register_plugin(plugin_heartbeat)
    worker.register_plugin(plugin_traffic_accounting_info)
    worker.register_plugin(plugin_agent_info)

    print "Starting worker..."
    print "id=%s, log=%s" % (worker.worker_id, cfg['log'])
    print "server is %s:%s" % (cfg['feedback_host'], cfg['feedback_port'])

    # Process messages from broadcast
    poller = zmq.Poller()
    poller.register(broadcast, zmq.POLLIN)

    # Process messages from both sockets
    while running:
        try:
            socks = dict(poller.poll(worker.working_rate))
        except zmq.core.error.ZMQError:
            pass
        # parse the command from server
        if socks.get(broadcast) == zmq.POLLIN:
            msg_type, msg_id, msg_body = broadcast.recv_multipart()
            # Process task
            message = json.loads(msg_body)
            if message['dest'] in ['ALL', WORKER_ID]:
                logger.debug(message['cmd'], message['opt'])
            # Send results to feedback
            worker.send([msg_type, msg_id,
                                     json.dumps({'worker_id': WORKER_ID,
                                                 'status': 200})])

        # push the info data to server
        worker.info_push()
        
        if not running:
            break
    poller.unregister(broadcast)
        
        
if __name__ == '__main__':
    main(True)
